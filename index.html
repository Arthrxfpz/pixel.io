<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Editor de Desenho Avançado</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
body {
  margin: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #111;
  color: white;
  font-family: Arial, sans-serif;
  transform-origin: 0 0;
  transition: transform 0.2s ease;
}

h1 {
  margin-top: 10px;
}

#toolbar {
  margin: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

#pens, #shapes {
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
  background: #222;
  padding: 5px;
  border-radius: 8px;
}

button, input[type=color], input[type=range], label span {
  font-size: 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

button {
  padding: 8px;
  background: #333;
  color: white;
}

button:hover, button.selected {
  background-color: #555;
}

canvas {
  border: 2px solid white;
  background-color: #fff;
  touch-action: none;
  margin-bottom: 20px;
}

#sizeValue {
  margin-left: 5px;
}

.cursor-cross {
  cursor: crosshair !important;
}

#colorPalette {
  display: flex;
  gap: 10px;
  background: #222;
  padding: 10px;
  border-radius: 12px;
  align-items: center;
}

.color-option {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #444;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 14px;
  transition: transform 0.2s, border 0.2s;
}

.color-option:hover {
  transform: scale(1.1);
  border-color: #888;
}

/* Cor selecionada */
.color-selected {
  border-color: white !important;
  transform: scale(1.15);
}

/* Input nativo escondido */
#colorPicker {
  display: none;
}
/* Caixa geral dos ajustes */
#adjustments {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 10px;
  background: #181818;
  padding: 12px;
  border-radius: 12px;
  box-shadow: 0 0 10px #0006;
  justify-content: center;
}

/* Cada card */
.control-box {
  background: #222;
  padding: 10px 14px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  gap: 10px;
  width: 260px;
  box-shadow: 0 0 10px #0004;
}

/* Ícone */
.control-box i {
  font-size: 22px;
  color: #0af;
}

/* Nome do ajuste */
.control-box label {
  font-weight: bold;
  width: 110px;
}

/* Valor (5px, 100%) */
.control-box span {
  width: 50px;
  text-align: right;
  font-size: 14px;
}

/* Slider estilizado */
.control-box input[type=range] {

  width: 100%;
  height: 6px;
  border-radius: 5px;
  background: #444;
}

.control-box input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #0af;
  border-radius: 50%;
  cursor: pointer;
}

.control-box input[type=range]::-webkit-slider-thumb:hover {
  background: #09f;
}

.resolution-container {
  position: relative;
  display: inline-block;
}

#resolutionBtn {
  padding: 10px;
  font-size: 18px;
  border: none;
  background: #333;
  color: white;
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
}

#resolutionBtn:hover {
  background: #555;
}

.resolution-menu {
  display: none;
  position: absolute;
  top: 50px;
  left: 0;
  background: #222;
  color: white;
  padding: 15px;
  width: 180px;
  border-radius: 10px;
  box-shadow: 0 0 15px rgba(0,0,0,0.4);
  z-index: 1000;
}

.resolution-menu h4 {
  margin: 10px 0 5px;
  font-size: 14px;
  color: #ccc;
}

.res-option,
#applyCustom {
  width: 100%;
  margin: 5px 0;
  padding: 8px;
  border: none;
  background: #444;
  color: white;
  border-radius: 6px;
  cursor: pointer;
  transition: 0.2s;
}

.res-option:hover,
#applyCustom:hover {
  background: #666;
}

#customW,
#customH {
  width: 100%;
  padding: 6px;
  margin: 4px 0;
  border-radius: 6px;
  border: none;
  background: #333;
  color: white;
}
#canvasWrapper {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

#canvas {
  transform-origin: top left;
}

</style>
</head>
<body>

<h1>Pixel IO</h1>

<div id="toolbar">

  <!-- Área de Canetas -->
  <div id="pens">
    <button id="penTiles" title="Pincel de Ladrilhos"><i class="fas fa-border-all"></i></button>
<button id="penCalligraphy" title="Caligrafia"><i class="fas fa-signature"></i></button>
<button id="penSpray" title="Spray de Tinta"><i class="fas fa-spray-can"></i></button>

    <button id="pencil" class="selected" title="Lápis Normal"><i class="fas fa-pencil-alt"></i></button>
    <button id="penThin" title="Caneta Fina"><i class="fas fa-pen"></i> Fina</button>
    <button id="penMedium" title="Caneta Média"><i class="fas fa-pen"></i> Média</button>
    <button id="penThick" title="Caneta Grossa"><i class="fas fa-pen"></i> Grossa</button>
    <button id="penNeon" title="Caneta Neon"><i class="fas fa-lightbulb"></i> Neon</button>
   <button id="penBlur" class="tool-btn" title="Desfoque">
    <i class="fa-solid fa-droplet"></i>
</button>


    <button id="eyedropper" title="Pipeta"><i class="fas fa-eye-dropper"></i></button>
    <button id="eraser" title="Borracha"><i class="fas fa-eraser"></i></button>
  </div>

  <!-- Área de Formas -->
  <div id="shapes">
    <button id="line" title="Linha"><i class="fas fa-slash"></i></button>
    <button id="rect" title="Retângulo"><i class="far fa-square"></i></button>
    <button id="circle" title="Círculo"><i class="far fa-circle"></i></button>
    <button id="triangle" title="Triângulo"><i class="fas fa-play"></i></button>
    <button id="diamond" title="Losango"><i class="fas fa-gem"></i></button>
    <button id="star" title="Estrela"><i class="fas fa-star"></i></button>
    <button id="fill" title="Preencher"><i class="fas fa-fill-drip"></i></button>
    <button id="undo" title="Desfazer"><i class="fas fa-rotate-left"></i></button>
    <button id="redo" title="Refazer"><i class="fas fa-rotate-right"></i></button>
    <button id="save" title="Salvar"><i class="fas fa-download"></i></button>
    <button id="clearAll" title="Apagar Tudo"><i class="fas fa-trash"></i></button>
<div class="resolution-container">
  <button id="resolutionBtn" title="Escolher Resolução">
    <i class="fas fa-expand-arrows-alt"></i>
  </button>

  <!-- MINI MENU QUE ABRE -->
  <div id="resolutionMenu" class="resolution-menu">
    <h4>Resoluções</h4>
    <button class="res-option" data-w="800" data-h="600">800 × 600</button>
    <button class="res-option" data-w="1024" data-h="768">1024 × 768</button>
    <button class="res-option" data-w="1280" data-h="720">1280 × 720</button>
    <button class="res-option" data-w="1920" data-h="1080">1920 × 1080</button>

    <h4>Personalizada</h4>
    <input type="number" id="customW" placeholder="Largura">
    <input type="number" id="customH" placeholder="Altura">
    <button id="applyCustom">Aplicar</button>
  </div>
</div>
  </div>

  <div id="colorPalette">
  <div class="color-option" data-color="#000000" style="background:#000000"></div>
  <div class="color-option" data-color="#ff0000" style="background:#ff0000"></div>
  <div class="color-option" data-color="#00ff00" style="background:#00ff00"></div>
  <div class="color-option" data-color="#0000ff" style="background:#0000ff"></div>
  <div class="color-option" data-color="#ffff00" style="background:#ffff00"></div>
  <div class="color-option" data-color="#ff00ff" style="background:#ff00ff"></div>
  <div class="color-option" data-color="#00ffff" style="background:#00ffff"></div>

  <!-- Cor personalizada -->
  <div id="customColor" class="color-option">
    <i class="fas fa-plus"></i>
  </div>

  <!-- Input color escondido -->
  <input type="color" id="colorPicker" value="#000000">
</div>

 <div id="adjustments">
  <div class="control-box">
    <i class="fas fa-circle-notch"></i>
    <label>Grossura</label>
    <input type="range" id="sizePicker" min="1" max="50" value="5">
    <span id="sizeValue">5px</span>
  </div>

  <div class="control-box">
    <i class="fas fa-tint"></i>
    <label>Transparência</label>
    <input type="range" id="alphaPicker" min="0" max="100" value="100">
    <span id="alphaValue">100%</span>
  </div>
</div>

</div>

<div id="canvasWrapper">
  <canvas id="canvas" width="800" height="600"></canvas>
</div>

<script>
// ==== SCRIPT COMPLETO DO EDITOR ====

// elementos principais
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// --- Estado do desenho ---
let drawing = false;
let startX = 0, startY = 0;
let tool = 'pencil';
let color = document.getElementById('colorPicker').value;
let size = parseInt(document.getElementById('sizePicker').value);
let alpha = 1.0;
let currentPath = []; // array de pontos {x,y} — para todas as canetas salvamos o path
let undoStack = [], redoStack = [], MAX_HISTORY = 50;

// --- Botões (lista com novos tools já incluídos) ---
const toolButtons = [
  'pencil','penThin','penMedium','penThick','penNeon',
  'penTiles','penCalligraphy','penSpray','penBlur',
  'eyedropper','eraser',
  'line','rect','circle','triangle','diamond','star','fill'
];

toolButtons.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('click', () => {
    tool = id;
    toolButtons.forEach(b => {
      const e = document.getElementById(b);
      if (e) e.classList.remove('selected');
    });
    el.classList.add('selected');

    // cursor para pipeta
    if (tool === 'eyedropper') canvas.classList.add('cursor-cross');
    else canvas.classList.remove('cursor-cross');

    // reset tamanho quando volta pro lápis
    if (tool === 'pencil') size = parseInt(document.getElementById('sizePicker').value);
    // atualizar cor variável
    const cpEl = document.getElementById('colorPicker');
    if (cpEl) color = cpEl.value;
  });
});

// --- Cor, tamanho e alpha ---
const cp = document.getElementById('colorPicker');
if (cp) cp.addEventListener('input', e => color = e.target.value);

const sizePicker = document.getElementById('sizePicker');
if (sizePicker) {
  sizePicker.addEventListener('input', e => {
    size = parseInt(e.target.value);
    const el = document.getElementById('sizeValue');
    if (el) el.textContent = size + 'px';
  });
}

const alphaPicker = document.getElementById('alphaPicker');
const alphaValue = document.getElementById('alphaValue');
if (alphaPicker) {
  alphaPicker.addEventListener('input', e => {
    alpha = parseInt(e.target.value) / 100;
    if (alphaValue) alphaValue.textContent = e.target.value + '%';
  });
}

// --- Undo/Redo ---
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');
if (undoBtn) undoBtn.addEventListener('click', () => { undo(); redrawCanvas(); });
if (redoBtn) redoBtn.addEventListener('click', () => { redo(); redrawCanvas(); });

function addAction(action) {
  undoStack.push({ ...action, timestamp: Date.now() });
  redoStack = [];
  if (undoStack.length > MAX_HISTORY) undoStack.shift();
}
function undo() {
  if (undoStack.length === 0) return;
  redoStack.push(undoStack.pop());
}
function redo() {
  if (redoStack.length === 0) return;
  undoStack.push(redoStack.pop());
}

// --- salvar / exportar ---
const saveBtn = document.getElementById('save');
if (saveBtn) saveBtn.addEventListener('click', () => {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = canvas.width;
  tempCanvas.height = canvas.height;
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.fillStyle = '#ffffff';
  tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  tempCtx.drawImage(canvas, 0, 0);
  const link = document.createElement('a');
  link.download = 'desenho.png';
  link.href = tempCanvas.toDataURL('image/png');
  link.click();
});

// --- Clear All ---
const clearAllBtn = document.getElementById('clearAll');
if (clearAllBtn) clearAllBtn.addEventListener('click', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  undoStack = []; redoStack = [];
  currentPath = []; drawing = false; startX = 0; startY = 0;
});

// --- funções utilitárias para cores e alpha ---
function applyAlpha(hex, a) {
  const rgb = hexToRgb(hex);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
}
function hexToRgb(hex) {
  hex = (hex || '#000000').replace('#', '');
  if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
  return {
    r: parseInt(hex.substring(0,2), 16),
    g: parseInt(hex.substring(2,4), 16),
    b: parseInt(hex.substring(4,6), 16)
  };
}
function rgbToHex(r,g,b){ return "#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }

// --- Funções de desenho base ---
function drawPath(ctx, path, strokeStyle, lineWidth, shadow=false) {
  if (!path || path.length < 2) return;
  ctx.save();
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = strokeStyle;
  ctx.shadowBlur = shadow ? 20 : 0;
  ctx.shadowColor = shadow ? strokeStyle : '';
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawShape(ctx, data) {
  ctx.save();
  ctx.lineWidth = data.size;
  ctx.strokeStyle = data.strokeStyle;
  ctx.shadowBlur = data.shadow ? 25 : 0;
  ctx.shadowColor = data.shadow ? data.strokeStyle : '';
  if (data.shape === 'line') { ctx.beginPath(); ctx.moveTo(data.x1,data.y1); ctx.lineTo(data.x2,data.y2); ctx.stroke(); }
  else if (data.shape === 'rect') ctx.strokeRect(data.x,data.y,data.w,data.h);
  else if (data.shape === 'circle') { ctx.beginPath(); ctx.arc(data.x,data.y,data.r,0,Math.PI*2); ctx.stroke(); }
  else if (data.shape === 'triangle') { ctx.beginPath(); ctx.moveTo(data.x,data.y); ctx.lineTo(data.x+data.w/2,data.y+data.h); ctx.lineTo(data.x-data.w/2,data.y+data.h); ctx.closePath(); ctx.stroke(); }
  else if (data.shape === 'diamond') { ctx.beginPath(); ctx.moveTo(data.x,data.y-data.h/2); ctx.lineTo(data.x+data.w/2,data.y); ctx.lineTo(data.x,data.y+data.h/2); ctx.lineTo(data.x-data.w/2,data.y); ctx.closePath(); ctx.stroke(); }
  else if (data.shape === 'star') drawStar(ctx,data.x,data.y,data.r,5);
  ctx.restore();
}

function drawStar(ctx, cx, cy, r, points) {
  const angle = Math.PI / points;
  ctx.beginPath();
  for (let i = 0; i < 2*points; i++) {
    const rad = i % 2 === 0 ? r : r/2;
    const x = cx + Math.cos(i*angle - Math.PI/2) * rad;
    const y = cy + Math.sin(i*angle - Math.PI/2) * rad;
    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath(); ctx.stroke();
}

// --- Bucket fill (seu código original) ---
function bucketFill(x,y,fillHex,fillAlpha){
  const fillColor=hexToRgb(fillHex);
  const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);
  const data=imageData.data; const width=canvas.width; const height=canvas.height;
  const targetColor=getPixelColor(x,y,data,width); const fillRGBA=[fillColor.r,fillColor.g,fillColor.b,Math.round(fillAlpha*255)];
  if(colorsMatch(targetColor,fillRGBA)) return;
  const stack=[[Math.floor(x),Math.floor(y)]]; const tol=15;
  while(stack.length){
    const [px,py]=stack.pop(); let py1=py; while(py1>=0 && colorsMatch(getPixelColor(px,py1,data,width),targetColor,tol)) py1--; py1++;
    let reachLeft=false, reachRight=false;
    for(;py1<height && colorsMatch(getPixelColor(px,py1,data,width),targetColor,tol);py1++){
      let idx=(py1*width+px)*4; colorPixel(data,idx,fillRGBA);
      if(px>0){ if(colorsMatch(getPixelColor(px-1,py1,data,width),targetColor,tol)){ if(!reachLeft){stack.push([px-1,py1]); reachLeft=true;} } else reachLeft=false;}
      if(px<width-1){ if(colorsMatch(getPixelColor(px+1,py1,data,width),targetColor,tol)){ if(!reachRight){stack.push([px+1,py1]); reachRight=true;} } else reachRight=false;}
    }
  }
  ctx.putImageData(imageData,0,0);
}
function getPixelColor(x,y,data,width){const idx=(y*width+x)*4; return [data[idx],data[idx+1],data[idx+2],data[idx+3]];}
function colorPixel(data,pos,color){data[pos]=color[0]; data[pos+1]=color[1]; data[pos+2]=color[2]; data[pos+3]=color[3];}
function colorsMatch(c1,c2,tol=0){return Math.abs(c1[0]-c2[0])<=tol && Math.abs(c1[1]-c2[1])<=tol && Math.abs(c1[2]-c2[2])<=tol && Math.abs(c1[3]-c2[3])<=tol;}

// --- Novas canetas: implementações das funções utilizadas ---
function drawTilesBrush(x, y, sizeLocal, colorLocal) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = colorLocal;
  const tileSize = Math.max(1, Math.round(sizeLocal * 2));
  const tx = Math.floor(x / tileSize) * tileSize;
  const ty = Math.floor(y / tileSize) * tileSize;
  ctx.fillRect(tx, ty, tileSize, tileSize);
  ctx.restore();
}

function drawCalligraphy(x, y, sizeLocal, colorLocal) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = colorLocal;
  ctx.translate(x, y);
  ctx.rotate(-20 * Math.PI / 180);
  ctx.fillRect(-sizeLocal * 0.75, -sizeLocal * 0.25, sizeLocal * 1.5, sizeLocal * 0.5);
  ctx.restore();
}

function drawSpray(x, y, sizeLocal, colorLocal) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = colorLocal;
  const density = Math.max(8, Math.round(sizeLocal * 2.2));
  for (let i = 0; i < density; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * sizeLocal * 0.8;
    const px = x + Math.cos(angle) * radius;
    const py = y + Math.sin(angle) * radius;
    ctx.fillRect(px, py, 1, 1);
  }
  ctx.restore();
}

// ---------------- CANETA DE DESFOQUE --------------------
function drawBlurBrush(x, y, sizeLocal) {
    const blurAmount = Math.max(1, Math.round(sizeLocal * 0.6)); // nível de desfoque

    // cria canvas temporário do tamanho do brush (mais eficiente)
    const box = Math.ceil(sizeLocal * 2) + 4;
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = box;
    tempCanvas.height = box;
    const tctx = tempCanvas.getContext("2d");

    // coordenadas no canvas principal
    const sx = Math.round(x - box/2);
    const sy = Math.round(y - box/2);

    // copiar somente a região do canvas principal pro temporário
    // lidar limites (clamp)
    const sxClamped = Math.max(0, Math.min(canvas.width - box, sx));
    const syClamped = Math.max(0, Math.min(canvas.height - box, sy));

    tctx.drawImage(canvas, sxClamped, syClamped, box, box, 0, 0, box, box);

    // aplica desfoque no temporário
    tctx.filter = `blur(${blurAmount}px)`;
    // redesenha ele mesmo para aplicar o filtro
    const tmp = document.createElement("canvas");
    tmp.width = box; tmp.height = box;
    const tmpCtx = tmp.getContext("2d");
    tmpCtx.filter = `blur(${blurAmount}px)`;
    tmpCtx.drawImage(tctx.canvas, 0, 0);

    // cola de volta na posição correta
    ctx.drawImage(tmp, 0, 0, box, box, sxClamped, syClamped, box, box);
}
// ------------------------------------------------------

// --- Função que reaplica uma ação de 'draw' no redo/undo ---
function replayDraw(data) {
  const toolName = data.tool || 'pencil';
  const stroke = data.strokeStyle || applyAlpha('#000000', 1);
  const s = data.size || 3;

  if (toolName === 'penSpray') {
    // path tem pontos {x,y} -> para cada ponto desenha spray usando size
    for (const p of data.path) {
      drawSpray(p.x, p.y, s, stroke);
    }
    return;
  }

  if (toolName === 'penTiles') {
    for (const p of data.path) {
      drawTilesBrush(p.x, p.y, s, stroke);
    }
    return;
  }

  if (toolName === 'penCalligraphy') {
    for (const p of data.path) {
      drawCalligraphy(p.x, p.y, s, stroke);
    }
    return;
  }

  if (toolName === 'penBlur') {
    for (const p of data.path) {
      drawBlurBrush(p.x, p.y, s);
    }
    return;
  }

  // default: desenhar path com drawPath
  drawPath(ctx, data.path, stroke, s, data.shadow || false);
}

// --- Aplicar ações no redraw ---
function applyAction(action) {
  switch (action.type) {
    case 'draw':
      replayDraw(action.data);
      break;
    case 'erase':
      drawPath(ctx, action.data.path, '#fff', action.data.size || 10);
      break;
    case 'fill':
      bucketFill(action.data.x, action.data.y, action.data.color, action.data.alpha);
      break;
    case 'shape':
      drawShape(ctx, action.data);
      break;
  }
}

function redrawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const a of undoStack) applyAction(a);
}

// --- Início / Desenho / Parada ---
function startDraw(x, y) {
  startX = x; startY = y;
  currentPath = [{ x, y }];
  // fill e eyedropper agem na hora
  if (tool === 'fill') {
    addAction({ type: 'fill', data: { x, y, color: color, alpha: alpha } });
    redrawCanvas();
    return;
  }
  if (tool === 'eyedropper') {
    const img = ctx.getImageData(Math.round(x), Math.round(y), 1, 1).data;
    color = rgbToHex(img[0], img[1], img[2]);
    const cp = document.getElementById('colorPicker');
    if (cp) cp.value = color;
    tool = 'pencil';
    toolButtons.forEach(b => {
      const e = document.getElementById(b);
      if (e) e.classList.remove('selected');
    });
    const p = document.getElementById('pencil');
    if (p) p.classList.add('selected');
    canvas.classList.remove('cursor-cross');
    return;
  }
  drawing = true;
}

function draw(x, y) {
  if (!drawing) return;

  let strokeStyle = applyAlpha(color, alpha);
  let shadow = false;
  if (tool === 'penNeon') shadow = true;

  // ajustar tamanhos básicos
  if (tool === 'penThin') size = 2;
  else if (tool === 'penMedium') size = 5;
  else if (tool === 'penThick') size = 10;

  // ------- Novas canetas: tiles, caligrafia e spray -------
  if (tool === 'penTiles') {
    drawTilesBrush(x, y, size, strokeStyle);
    currentPath.push({ x, y });
    return;
  }

  if (tool === 'penCalligraphy') {
    drawCalligraphy(x, y, size, strokeStyle);
    currentPath.push({ x, y });
    return;
  }

  if (tool === 'penSpray') {
    drawSpray(x, y, size, strokeStyle);
    currentPath.push({ x, y });
    return;
  }
  // ------------------------------------------------------

  // caneta de desfoque
  if (tool === 'penBlur') {
    drawBlurBrush(x, y, size);
    currentPath.push({ x, y });
    return;
  }

  // canetas normais / lápis / neon
  if (tool === 'pencil' || tool === 'penThin' || tool === 'penMedium' || tool === 'penThick' || tool === 'penNeon') {
    currentPath.push({ x, y });
    drawPath(ctx, currentPath, tool === 'eraser' ? '#fff' : strokeStyle, size, shadow);
    return;
  }

  if (tool === 'eraser') {
    currentPath.push({ x, y });
    drawPath(ctx, currentPath, '#fff', size, false);
    return;
  }

  // formas (tem que redesenhar preview)
  redrawCanvas();
  if (tool === 'line') drawShape(ctx, { shape: 'line', x1: startX, y1: startY, x2: x, y2: y, strokeStyle: strokeStyle, size: size, shadow: shadow });
  if (tool === 'rect') drawShape(ctx, { shape: 'rect', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow });
  if (tool === 'circle') {
    const r = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
    drawShape(ctx, { shape: 'circle', x: startX, y: startY, r: r, strokeStyle: strokeStyle, size: size, shadow: shadow });
  }
  if (tool === 'triangle') drawShape(ctx, { shape: 'triangle', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow });
  if (tool === 'diamond') drawShape(ctx, { shape: 'diamond', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow });
  if (tool === 'star') {
    const r = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
    drawShape(ctx, { shape: 'star', x: startX, y: startY, r: r, strokeStyle: strokeStyle, size: size, shadow: shadow });
  }
}

function stopDraw(x, y) {
  if (!drawing) return;
  drawing = false;

  let strokeStyle = applyAlpha(color, alpha);
  let shadow = false;
  if (tool === 'penNeon') shadow = true;
  if (tool === 'penThin') size = 2; else if (tool === 'penMedium') size = 5; else if (tool === 'penThick') size = 10;

  // registrar ação (salvamos tool dentro de data para poder refazer corretamente)
  if (tool === 'pencil' || tool === 'penThin' || tool === 'penMedium' || tool === 'penThick' || tool === 'penNeon' ||
      tool === 'penTiles' || tool === 'penCalligraphy' || tool === 'penSpray' || tool === 'penBlur') {
    addAction({
      type: 'draw',
      data: { tool: tool, path: currentPath.slice(), strokeStyle: strokeStyle, size: size, shadow: shadow }
    });
  } else if (tool === 'eraser') {
    addAction({ type: 'erase', data: { path: currentPath.slice(), size: size } });
  } else if (tool === 'line') {
    addAction({ type: 'shape', data: { shape: 'line', x1: startX, y1: startY, x2: x, y2: y, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  } else if (tool === 'rect') {
    addAction({ type: 'shape', data: { shape: 'rect', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  } else if (tool === 'circle') {
    const r = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
    addAction({ type: 'shape', data: { shape: 'circle', x: startX, y: startY, r: r, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  } else if (tool === 'triangle') {
    addAction({ type: 'shape', data: { shape: 'triangle', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  } else if (tool === 'diamond') {
    addAction({ type: 'shape', data: { shape: 'diamond', x: startX, y: startY, w: x - startX, h: y - startY, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  } else if (tool === 'star') {
    const r = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
    addAction({ type: 'shape', data: { shape: 'star', x: startX, y: startY, r: r, strokeStyle: strokeStyle, size: size, shadow: shadow } });
  }

  redrawCanvas();
}

// --- Eventos do canvas (mouse e touch) ---
let lastX = 0, lastY = 0;
canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(e.clientX - rect.left);
  const y = Math.round(e.clientY - rect.top);
  startDraw(x, y);
  lastX = x; lastY = y;
});
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(e.clientX - rect.left);
  const y = Math.round(e.clientY - rect.top);
  draw(x, y);
  lastX = x; lastY = y;
});
canvas.addEventListener('mouseup', e => stopDraw(lastX, lastY));
canvas.addEventListener('mouseleave', e => stopDraw(lastX, lastY));

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = Math.round(touch.clientX - rect.left);
  const y = Math.round(touch.clientY - rect.top);
  startDraw(x, y);
  lastX = x; lastY = y;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = Math.round(touch.clientX - rect.left);
  const y = Math.round(touch.clientY - rect.top);
  draw(x, y);
  lastX = x; lastY = y;
});
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  stopDraw(lastX, lastY);
});

// --- Cor palette e custom color ---
const colorOptions = document.querySelectorAll('.color-option');
const colorPicker = document.getElementById('colorPicker');
let selectedColorDiv = colorOptions && colorOptions[0] ? colorOptions[0] : null;

colorOptions.forEach(opt => {
  opt.addEventListener('click', () => {
    if (opt.id === "customColor") {
      colorPicker.click();
      return;
    }
    color = opt.dataset.color;
    if (colorPicker) colorPicker.value = color;
    if (selectedColorDiv) selectedColorDiv.classList.remove('color-selected');
    opt.classList.add('color-selected');
    selectedColorDiv = opt;
  });
});

if (colorPicker) {
  colorPicker.addEventListener('input', e => {
    color = e.target.value;
    if (selectedColorDiv) selectedColorDiv.classList.remove('color-selected');
    const custom = document.getElementById('customColor');
    if (custom) {
      custom.style.background = color;
      custom.classList.add('color-selected');
      selectedColorDiv = custom;
    }
  });
}

// --- Resolução (seu código de menu de resolução) ---
document.addEventListener("DOMContentLoaded", () => {
  const resolutionBtn = document.getElementById("resolutionBtn");
  const resolutionMenu = document.getElementById("resolutionMenu");
  if (!resolutionBtn || !resolutionMenu) return;

  resolutionBtn.addEventListener("click", () => {
    resolutionMenu.style.display = resolutionMenu.style.display === "block" ? "none" : "block";
  });

  document.addEventListener("click", (event) => {
    if (!resolutionMenu.contains(event.target) && !resolutionBtn.contains(event.target)) {
      resolutionMenu.style.display = "none";
    }
  });

  const quickButtons = document.querySelectorAll(".res-option");
  quickButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const w = parseInt(btn.dataset.w);
      const h = parseInt(btn.dataset.h);
      if (w > 0 && h > 0) resizeCanvas(w, h);
      resolutionMenu.style.display = "none";
    });
  });

  const applyCustom = document.getElementById("applyCustom");
  if (applyCustom) applyCustom.addEventListener("click", () => {
    const w = parseInt(document.getElementById("customW").value || 0);
    const h = parseInt(document.getElementById("customH").value || 0);
    if (w > 0 && h > 0) resizeCanvas(w, h);
    resolutionMenu.style.display = "none";
  });

  function resizeCanvas(w, h) {
    // salva imagem atual
    const temp = document.createElement('canvas');
    temp.width = canvas.width;
    temp.height = canvas.height;
    const tctx = temp.getContext('2d');
    tctx.drawImage(canvas, 0, 0);

    canvas.width = w;
    canvas.height = h;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(temp, 0, 0);
    // redrawn actions not necessary because we already drew temp
  }
});

// --- Ajustar canvas na tela (scale visual) ---
function ajustarCanvasNaTela() {
  const wrapper = document.getElementById("canvasWrapper");
  if (!wrapper) return;
  const wrapperW = wrapper.clientWidth;
  const wrapperH = wrapper.clientHeight;
  const scaleX = wrapperW / canvas.width;
  const scaleY = wrapperH / canvas.height;
  const scale = Math.min(scaleX, scaleY);
  canvas.style.transform = `scale(${scale})`;
}

// chamar ajuste inicial
ajustarCanvasNaTela();
window.addEventListener('resize', ajustarCanvasNaTela);

// ==== FIM DO SCRIPT ====


</script>

</body>
</html>
